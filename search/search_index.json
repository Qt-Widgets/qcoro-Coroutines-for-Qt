{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QCoro C++ Coroutine library for Qt5 and Qt6 Overview QCoro is a C++ library that provide set of tools to make use of C++20 coroutines in connection with certain asynchronous Qt actions. Take a look at the example below to see what an amazing thing coroutines are: QNetworkAccessManager networkAccessManager ; // co_await the reply - the coroutine is suspended until the QNetworkReply is finished. // While the coroutine is suspended, *the Qt event loop runs as usual*. const QNetworkReply * reply = co_await networkAccessManager . get ( url ); // Once the reply is finished, your code resumes here as if nothing amazing has just happened ;-) const auto data = reply -> readAll (); This library has only one class and one function that the user must be aware of: the class is QCoro::Task and must be used as a return type for any coroutine that co_await s a Qt type. The function is qCoro() and it provides coroutine-friendly wrappers for Qt types that have multiple asynchronous operations that the user may want to co_await (for example QProcess ). All the other code (basically everything in the QCoro::detail namespace) is here to provide the cogs and gears for the C++ coroutine machinery, making it possible to use Qt types with coroutines. The major benefit of using coroutines with Qt types is that it allows writing asynchronous code as if it were synchronous and, most importantly, while the coroutine is co_await ing, the Qt event loop runs as usual , meaning that your application remains responsive. This is a rather experimental library that I started working on to better understand coroutines in C++. After reading numerous articles and blog posts about coroutines, it still wasn't exactly clear to me how the whole thing works, so I started working on this library to get a better idea about coroutines. Coroutines Coroutines are regular functions, except that they can be suspended and resumed again. When a coroutine is suspended, it returns sort of a promise to the caller and the caller continues executing their code. At some point, the caller can use the newly introduced co_await keyword to wait for the returned promise to be fulfilled. When that happens, the caller is suspended and instead the coroutine is resumed. This allows writing asynchronous code as if it were synchronous, making it much easier to read and understand. That's not all that coroutines can do, you can read more about it in the 'Coroutines' section of this documentation. Supported Compilers This library requires a compiler that supports the Coroutine TS (obviously). Currently GCC, Clang and MSVC are supported. All examples were tested with GCC 10 and Clang 11, although even slightly older versions should work. In both GCC and Clang, coroutine support must be explicitly enabled. GCC To enable coroutines support in GCC, add -fcoroutines to CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically. Clang In Clang coroutines are still considered experimental (unlike in GCC), so you cannot mix Clang and libstdc++. You must use Clang with libc++. Coroutines are enabled by adding -fcoroutines-ts to CMAKE_CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines-ts -stdlib=libc++\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically. LLVM libc++ vs. GNU libstdc++ While both libraries implement the same standard they are not mutually compatible - for one thing LLVM's libc++ is a bit behind libstdc++ on implementing all the features, but more importantly they are not ABI compatible. That means that if you compile Qt with libstdc++ (which most Linux distributions do) and your application with QCoro using libc++, you will likely run into undefined reference errors when linking your app against Qt. One option is to build Qt youself with libc++, other option is to use GCC or MSVC and avoid Clang until it has full support for coroutines, which will hopefully allow using libstdc++ with Clang. MSVC Coroutine support in MSVC is enabled automatically by CMake when C++20 standard is specified in CMAKE_CXX_STANDARD : set(CMAKE_CXX_STANDARD 20)","title":"Home"},{"location":"#qcoro","text":"C++ Coroutine library for Qt5 and Qt6","title":"QCoro"},{"location":"#overview","text":"QCoro is a C++ library that provide set of tools to make use of C++20 coroutines in connection with certain asynchronous Qt actions. Take a look at the example below to see what an amazing thing coroutines are: QNetworkAccessManager networkAccessManager ; // co_await the reply - the coroutine is suspended until the QNetworkReply is finished. // While the coroutine is suspended, *the Qt event loop runs as usual*. const QNetworkReply * reply = co_await networkAccessManager . get ( url ); // Once the reply is finished, your code resumes here as if nothing amazing has just happened ;-) const auto data = reply -> readAll (); This library has only one class and one function that the user must be aware of: the class is QCoro::Task and must be used as a return type for any coroutine that co_await s a Qt type. The function is qCoro() and it provides coroutine-friendly wrappers for Qt types that have multiple asynchronous operations that the user may want to co_await (for example QProcess ). All the other code (basically everything in the QCoro::detail namespace) is here to provide the cogs and gears for the C++ coroutine machinery, making it possible to use Qt types with coroutines. The major benefit of using coroutines with Qt types is that it allows writing asynchronous code as if it were synchronous and, most importantly, while the coroutine is co_await ing, the Qt event loop runs as usual , meaning that your application remains responsive. This is a rather experimental library that I started working on to better understand coroutines in C++. After reading numerous articles and blog posts about coroutines, it still wasn't exactly clear to me how the whole thing works, so I started working on this library to get a better idea about coroutines.","title":"Overview"},{"location":"#coroutines","text":"Coroutines are regular functions, except that they can be suspended and resumed again. When a coroutine is suspended, it returns sort of a promise to the caller and the caller continues executing their code. At some point, the caller can use the newly introduced co_await keyword to wait for the returned promise to be fulfilled. When that happens, the caller is suspended and instead the coroutine is resumed. This allows writing asynchronous code as if it were synchronous, making it much easier to read and understand. That's not all that coroutines can do, you can read more about it in the 'Coroutines' section of this documentation.","title":"Coroutines"},{"location":"#supported-compilers","text":"This library requires a compiler that supports the Coroutine TS (obviously). Currently GCC, Clang and MSVC are supported. All examples were tested with GCC 10 and Clang 11, although even slightly older versions should work. In both GCC and Clang, coroutine support must be explicitly enabled.","title":"Supported Compilers"},{"location":"#gcc","text":"To enable coroutines support in GCC, add -fcoroutines to CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically.","title":"GCC"},{"location":"#clang","text":"In Clang coroutines are still considered experimental (unlike in GCC), so you cannot mix Clang and libstdc++. You must use Clang with libc++. Coroutines are enabled by adding -fcoroutines-ts to CMAKE_CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines-ts -stdlib=libc++\") Alternatively, just use qcoro_enable_coroutines() CMake macro provided by QCoro to set the flags automatically. LLVM libc++ vs. GNU libstdc++ While both libraries implement the same standard they are not mutually compatible - for one thing LLVM's libc++ is a bit behind libstdc++ on implementing all the features, but more importantly they are not ABI compatible. That means that if you compile Qt with libstdc++ (which most Linux distributions do) and your application with QCoro using libc++, you will likely run into undefined reference errors when linking your app against Qt. One option is to build Qt youself with libc++, other option is to use GCC or MSVC and avoid Clang until it has full support for coroutines, which will hopefully allow using libstdc++ with Clang.","title":"Clang"},{"location":"#msvc","text":"Coroutine support in MSVC is enabled automatically by CMake when C++20 standard is specified in CMAKE_CXX_STANDARD : set(CMAKE_CXX_STANDARD 20)","title":"MSVC"},{"location":"building-and-using/","text":"Building and Using QCoro Building QCoro QCoro uses CMake build system. You can pass following options to the cmake command when building QCoro to customize the build: -DQCORO_BUILD_EXAMPLES - whether to build examples or not ( ON by default). -DQCORO_ENABLE_ASAN - whether to build QCoro with AddressSanitizer ( OFF by default). -DBUILD_SHARED_LIBS - whether to build QCoro as a shared library ( OFF by default). -DBUILD_TESTING - whether to build tests ( ON by default). -DUSE_QT_VERSION - set to 5 or 6 to force a particular version of Qt. When not set the highest available version is used. -DQCORO_WITH_QTDBUS - whether to compile support for QtDBus ( ON by default). -DQCORO_WITH_QTNETWORK - whether to compile support for QtNetwork ( ON by default). mkdir build cd build cmake .. <CMAKE FLAGS> make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install Add it to your CMake Depending on whether you want to use Qt5 or Qt6 build of QCoro, you should use QCoro5 or QCoro6` in your CMake code, respectively. The example below is assuming Qt6: # Use QCoro5 if you are building for Qt5! find_package ( QCoro6 REQUIRED COMPONENTS Core Network DBus ) # Set necessary compiler flags to enable coroutine support qcoro_enable_coroutines () ... target_link_libraries ( your-target QCoro::Core QCoro::Network QCoro::DBus ) Note the missing Qt version number in the QCoro target namespace: QCoro provides both versioned ( QCoro5 and QCoro6 ) namespaces as well as version-less namespace, which is especially useful for transitioning codebase from Qt5 to Qt6.","title":"Building and Using QCoro"},{"location":"building-and-using/#building-and-using-qcoro","text":"","title":"Building and Using QCoro"},{"location":"building-and-using/#building-qcoro","text":"QCoro uses CMake build system. You can pass following options to the cmake command when building QCoro to customize the build: -DQCORO_BUILD_EXAMPLES - whether to build examples or not ( ON by default). -DQCORO_ENABLE_ASAN - whether to build QCoro with AddressSanitizer ( OFF by default). -DBUILD_SHARED_LIBS - whether to build QCoro as a shared library ( OFF by default). -DBUILD_TESTING - whether to build tests ( ON by default). -DUSE_QT_VERSION - set to 5 or 6 to force a particular version of Qt. When not set the highest available version is used. -DQCORO_WITH_QTDBUS - whether to compile support for QtDBus ( ON by default). -DQCORO_WITH_QTNETWORK - whether to compile support for QtNetwork ( ON by default). mkdir build cd build cmake .. <CMAKE FLAGS> make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install","title":"Building QCoro"},{"location":"building-and-using/#add-it-to-your-cmake","text":"Depending on whether you want to use Qt5 or Qt6 build of QCoro, you should use QCoro5 or QCoro6` in your CMake code, respectively. The example below is assuming Qt6: # Use QCoro5 if you are building for Qt5! find_package ( QCoro6 REQUIRED COMPONENTS Core Network DBus ) # Set necessary compiler flags to enable coroutine support qcoro_enable_coroutines () ... target_link_libraries ( your-target QCoro::Core QCoro::Network QCoro::DBus ) Note the missing Qt version number in the QCoro target namespace: QCoro provides both versioned ( QCoro5 and QCoro6 ) namespaces as well as version-less namespace, which is especially useful for transitioning codebase from Qt5 to Qt6.","title":"Add it to your CMake"},{"location":"changelog/","text":"Changelog 0.4.0 (2022-01-06) Major highlights in this release: Co-installability of Qt5 and Qt6 builds of QCoro Complete re-work of CMake configuration Support for compiling QCoro with Clang against libstdc++ Co-installability of Qt5 and Qt6 builds of QCoro This change mostly affects packagers of QCoro. It is now possible to install both Qt5 and Qt6 versions of QCoro alongside each other without conflicting files. The shared libraries now contain the Qt version number in their name (e.g. libQCoro6Core.so ) and header files are also located in dedicated subdirectories (e.g. /usr/include/qcoro6/{qcoro,QCoro} ). User of QCoro should not need to do any changes to their codebase. Complete re-work of CMake configuration This change affects users of QCoro, as they will need to adjust CMakeLists.txt of their projects. First, depending on whether they want to use Qt5 or Qt6 version of QCoro, a different package must be used. Additionally, list of QCoro components to use must be specified: find_package(QCoro5 REQUIRED COMPONENTS Core Network DBus) Finally, the target names to use in target_link_libraries have changed as well: QCoro::Core QCoro::Network QCoro::DBus The version-less QCoro namespace can be used regardless of whether using Qt5 or Qt6 build of QCoro. QCoro5 and QCoro6 namespaces are available as well, in case users need to combine both Qt5 and Qt6 versions in their codebase. This change brings QCoro CMake configuration system to the same style and behavior as Qt itself, so it should now be easier to use QCoro, especially when supporting both Qt5 and Qt6. Support for compiling QCoro with Clang against libstdc++ Until now, when the Clang compiler was detected, QCoro forced usage of LLVM's libc++ standard library. Coroutine support requires tight co-operation between the compiler and standard library. Because Clang still considers their coroutine support experimental it expects all coroutine-related types in standard library to be located in std::experimental namespace. In GNU's libstdc++, coroutines are fully supported and thus implemented in the std namespace. This requires a little bit of extra glue, which is now in place. Full changelog QCoro can now be built with Clang against libstdc++ ( #38 , #22 ) Qt5 and Qt6 builds of QCoro are now co-installable ( #36 , #37 ) Fixed early co_return not resuming the caller ( #24 , #35 ) Fixed QProcess example ( #34 ) Test suite has been improved and extended ( #29 , #31 ) Task move assignment operator checks for self-assignment ( #27 ) QCoro can now be built as a subdirectory inside another CMake project ( #25 ) Fixed QCoroCore/qcorocore.h header ( #23 ) DBus is disabled by default on Windows, Mac and Android ( #21 ) Thanks to everyone who contributed to QCoro! 0.3.0 (2021-10-11) Added SOVERSION to shared libraries ( #17 ) Fixed building tests when not building examples ( #19 ) Fixed CI Thanks to everyone who contributed to QCoro 0.3.0! 0.2.0 (2021-09-08) Library modularity The code has been reorganized into three modules (and thus three standalone libraries): QCoroCore, QCoroDBus and QCoroNetwork. QCoroCore contains the elementary QCoro tools ( QCoro::Task , qCoro() wrapper etc.) and coroutine support for some QtCore types. The QCoroDBus module contains coroutine support for types from the QtDBus module and equally the QCoroNetwork module contains coroutine support for types from the QtNetwork module. The latter two modules are also optional, the library can be built without them. It also means that an application that only uses let's say QtNetwork and has no DBus dependency will no longer get QtDBus pulled in through QCoro, as long as it only links against libQCoroCore and libQCoroNetwork . The reorganization will also allow for future support of additional Qt modules. Headers clean up The include headers in QCoro we a bit of a mess and in 0.2.0 they all got a unified form. All public header files now start with qcoro (e.g. qcorotimer.h , qcoronetworkreply.h etc.), and QCoro also provides CamelCase headers now. Thus users should simply do #include <QCoroTimer> if they want coroutine support for QTimer . The reorganization of headers makes QCoro 0.2.0 incompatible with previous versions and any users of QCoro will have to update their #include statements. I'm sorry about this extra hassle, but with this brings much needed sanity into the header organization and naming scheme. Docs update The documentation has been updated to reflect the reorganization as well as some internal changes. It should be easier to understand now and hopefully will make it easier for users to start with QCoro now. Internal API cleanup and code de-duplication Historically, certain types types which can be directly co_await ed with QCoro, for instance QTimer has their coroutine support implemented differently than types that have multiple asynchronous operations and thus have a coroutine-friendly wrapper classes (like QIODevice and it's QCoroIODevice wrapper). In 0.2.0 I have unified the code so that even the coroutine support for simple types like QTimer are implemented through wrapper classes (so there's QCoroTimer now) 0.1.0 (2021-08-15) Initial release QCoro","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#040-2022-01-06","text":"Major highlights in this release: Co-installability of Qt5 and Qt6 builds of QCoro Complete re-work of CMake configuration Support for compiling QCoro with Clang against libstdc++","title":"0.4.0 (2022-01-06)"},{"location":"changelog/#co-installability-of-qt5-and-qt6-builds-of-qcoro","text":"This change mostly affects packagers of QCoro. It is now possible to install both Qt5 and Qt6 versions of QCoro alongside each other without conflicting files. The shared libraries now contain the Qt version number in their name (e.g. libQCoro6Core.so ) and header files are also located in dedicated subdirectories (e.g. /usr/include/qcoro6/{qcoro,QCoro} ). User of QCoro should not need to do any changes to their codebase.","title":"Co-installability of Qt5 and Qt6 builds of QCoro"},{"location":"changelog/#complete-re-work-of-cmake-configuration","text":"This change affects users of QCoro, as they will need to adjust CMakeLists.txt of their projects. First, depending on whether they want to use Qt5 or Qt6 version of QCoro, a different package must be used. Additionally, list of QCoro components to use must be specified: find_package(QCoro5 REQUIRED COMPONENTS Core Network DBus) Finally, the target names to use in target_link_libraries have changed as well: QCoro::Core QCoro::Network QCoro::DBus The version-less QCoro namespace can be used regardless of whether using Qt5 or Qt6 build of QCoro. QCoro5 and QCoro6 namespaces are available as well, in case users need to combine both Qt5 and Qt6 versions in their codebase. This change brings QCoro CMake configuration system to the same style and behavior as Qt itself, so it should now be easier to use QCoro, especially when supporting both Qt5 and Qt6.","title":"Complete re-work of CMake configuration"},{"location":"changelog/#support-for-compiling-qcoro-with-clang-against-libstdc","text":"Until now, when the Clang compiler was detected, QCoro forced usage of LLVM's libc++ standard library. Coroutine support requires tight co-operation between the compiler and standard library. Because Clang still considers their coroutine support experimental it expects all coroutine-related types in standard library to be located in std::experimental namespace. In GNU's libstdc++, coroutines are fully supported and thus implemented in the std namespace. This requires a little bit of extra glue, which is now in place.","title":"Support for compiling QCoro with Clang against libstdc++"},{"location":"changelog/#full-changelog","text":"QCoro can now be built with Clang against libstdc++ ( #38 , #22 ) Qt5 and Qt6 builds of QCoro are now co-installable ( #36 , #37 ) Fixed early co_return not resuming the caller ( #24 , #35 ) Fixed QProcess example ( #34 ) Test suite has been improved and extended ( #29 , #31 ) Task move assignment operator checks for self-assignment ( #27 ) QCoro can now be built as a subdirectory inside another CMake project ( #25 ) Fixed QCoroCore/qcorocore.h header ( #23 ) DBus is disabled by default on Windows, Mac and Android ( #21 ) Thanks to everyone who contributed to QCoro!","title":"Full changelog"},{"location":"changelog/#030-2021-10-11","text":"Added SOVERSION to shared libraries ( #17 ) Fixed building tests when not building examples ( #19 ) Fixed CI Thanks to everyone who contributed to QCoro 0.3.0!","title":"0.3.0 (2021-10-11)"},{"location":"changelog/#020-2021-09-08","text":"","title":"0.2.0 (2021-09-08)"},{"location":"changelog/#library-modularity","text":"The code has been reorganized into three modules (and thus three standalone libraries): QCoroCore, QCoroDBus and QCoroNetwork. QCoroCore contains the elementary QCoro tools ( QCoro::Task , qCoro() wrapper etc.) and coroutine support for some QtCore types. The QCoroDBus module contains coroutine support for types from the QtDBus module and equally the QCoroNetwork module contains coroutine support for types from the QtNetwork module. The latter two modules are also optional, the library can be built without them. It also means that an application that only uses let's say QtNetwork and has no DBus dependency will no longer get QtDBus pulled in through QCoro, as long as it only links against libQCoroCore and libQCoroNetwork . The reorganization will also allow for future support of additional Qt modules.","title":"Library modularity"},{"location":"changelog/#headers-clean-up","text":"The include headers in QCoro we a bit of a mess and in 0.2.0 they all got a unified form. All public header files now start with qcoro (e.g. qcorotimer.h , qcoronetworkreply.h etc.), and QCoro also provides CamelCase headers now. Thus users should simply do #include <QCoroTimer> if they want coroutine support for QTimer . The reorganization of headers makes QCoro 0.2.0 incompatible with previous versions and any users of QCoro will have to update their #include statements. I'm sorry about this extra hassle, but with this brings much needed sanity into the header organization and naming scheme.","title":"Headers clean up"},{"location":"changelog/#docs-update","text":"The documentation has been updated to reflect the reorganization as well as some internal changes. It should be easier to understand now and hopefully will make it easier for users to start with QCoro now.","title":"Docs update"},{"location":"changelog/#internal-api-cleanup-and-code-de-duplication","text":"Historically, certain types types which can be directly co_await ed with QCoro, for instance QTimer has their coroutine support implemented differently than types that have multiple asynchronous operations and thus have a coroutine-friendly wrapper classes (like QIODevice and it's QCoroIODevice wrapper). In 0.2.0 I have unified the code so that even the coroutine support for simple types like QTimer are implemented through wrapper classes (so there's QCoroTimer now)","title":"Internal API cleanup and code de-duplication"},{"location":"changelog/#010-2021-08-15","text":"Initial release QCoro","title":"0.1.0 (2021-08-15)"},{"location":"about/license/","text":"License QCoro is published under the MIT License MIT License Copyright (c) 2021 Daniel Vr\u00e1til dvratil@kde.org Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"QCoro is published under the MIT License","title":"License"},{"location":"about/license/#mit-license","text":"Copyright (c) 2021 Daniel Vr\u00e1til dvratil@kde.org Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"coroutines/coawait/","text":"co_await Explained The following paragraphs try to explain what is a coroutine and what co_await does in some simple way. I don't guarantee that any of this is factically correct. For more gritty (and correct) details, refer to the articles linked at the bottom of this document. Coroutines, simply put, are like normal functions except that they can be suspended (and resumed) in the middle. When a coroutine is suspended, execution returns to the function that has called the coroutine. If that function is also a coroutine and is waiting ( co_await ing) for the current coroutine to finish, then it is suspended as well and the execution returns to the function that has called that coroutine and so on, until a function that is an actual function (not a coroutine) is reached. In case of a regular Qt program, this \"top-level\" non-coroutine function will be the Qt's event loop - which means that while your coroutine, when called from the Qt event loop is suspended, the Qt event loop will continue to run until the coroutine is resumed again. Amongst many other things, this allows you to write asynchronous code as if it were synchronous without blocking the Qt event loop and making your application unresponsive. See the different examples in this document. Now let's look at the co_await keyword. This keyword tells the compiler that this is the point where the coroutine wants to be suspended, until the awaited object (the awaitable ) is ready. Anything type can be awaitable - either because it directly implements the interface needed by the C++ coroutine machinery, or because some external tools (like this library) are provided to wrap that type into something that implements the awaitable interface. The C++ coroutines introduce two additional keywords - co_return and co_yield : From an application programmer point of view, co_return behaves exactly the same as return , except that you cannot use the regular return in coroutines. There are some major differences under the hood, though, which is likely why there's a special keyword for returning from coroutines. co_yield allows a coroutine to produce a result without actually returning. Can be used for writing generators. Currently, this library has no support/usage of co_yield , so I won't go into more details here.","title":"co_await Explained"},{"location":"coroutines/coawait/#co_await-explained","text":"The following paragraphs try to explain what is a coroutine and what co_await does in some simple way. I don't guarantee that any of this is factically correct. For more gritty (and correct) details, refer to the articles linked at the bottom of this document. Coroutines, simply put, are like normal functions except that they can be suspended (and resumed) in the middle. When a coroutine is suspended, execution returns to the function that has called the coroutine. If that function is also a coroutine and is waiting ( co_await ing) for the current coroutine to finish, then it is suspended as well and the execution returns to the function that has called that coroutine and so on, until a function that is an actual function (not a coroutine) is reached. In case of a regular Qt program, this \"top-level\" non-coroutine function will be the Qt's event loop - which means that while your coroutine, when called from the Qt event loop is suspended, the Qt event loop will continue to run until the coroutine is resumed again. Amongst many other things, this allows you to write asynchronous code as if it were synchronous without blocking the Qt event loop and making your application unresponsive. See the different examples in this document. Now let's look at the co_await keyword. This keyword tells the compiler that this is the point where the coroutine wants to be suspended, until the awaited object (the awaitable ) is ready. Anything type can be awaitable - either because it directly implements the interface needed by the C++ coroutine machinery, or because some external tools (like this library) are provided to wrap that type into something that implements the awaitable interface. The C++ coroutines introduce two additional keywords - co_return and co_yield : From an application programmer point of view, co_return behaves exactly the same as return , except that you cannot use the regular return in coroutines. There are some major differences under the hood, though, which is likely why there's a special keyword for returning from coroutines. co_yield allows a coroutine to produce a result without actually returning. Can be used for writing generators. Currently, this library has no support/usage of co_yield , so I won't go into more details here.","title":"co_await Explained"},{"location":"coroutines/qt-vs-coawait/","text":"Qt vs. co_await One of the best examples where coroutines simplify your code is when dealing with asynchronous operations, like network operations. Let's see how a simple HTTP request would be handled in Qt using the signals/slots mechanism: void MyClass::fetchData () { auto * nam = new QNetworkAccessManager ( this ); auto * reply = nam -> get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); QObject :: connect ( reply , & QNetworkReply :: finished , [ reply , nam ]() { const auto data = reply -> readAll (); doSomethingWithData ( data ); reply -> deleteLater (); nam -> deleteLater (); }); } Now let's see how the code looks like if we use coroutines: QCoro :: Task <> MyClass :: fetchData () { QNetworkReply nam ; auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); const auto data = reply -> readAll (); reply -> deleteLater (); doSomethingWithData ( data ); } The magic here is the co_await keyword which has turned our method fetchData() into a coroutine and suspended its execution while the network request was running. When the request finishes, the coroutine is resumed from where it was suspended and continues. And the best part? While the coroutine is suspended, the Qt event loop runs as usual!","title":"Qt vs. co_await"},{"location":"coroutines/qt-vs-coawait/#qt-vs-co_await","text":"One of the best examples where coroutines simplify your code is when dealing with asynchronous operations, like network operations. Let's see how a simple HTTP request would be handled in Qt using the signals/slots mechanism: void MyClass::fetchData () { auto * nam = new QNetworkAccessManager ( this ); auto * reply = nam -> get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); QObject :: connect ( reply , & QNetworkReply :: finished , [ reply , nam ]() { const auto data = reply -> readAll (); doSomethingWithData ( data ); reply -> deleteLater (); nam -> deleteLater (); }); } Now let's see how the code looks like if we use coroutines: QCoro :: Task <> MyClass :: fetchData () { QNetworkReply nam ; auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); const auto data = reply -> readAll (); reply -> deleteLater (); doSomethingWithData ( data ); } The magic here is the co_await keyword which has turned our method fetchData() into a coroutine and suspended its execution while the network request was running. When the request finishes, the coroutine is resumed from where it was suspended and continues. And the best part? While the coroutine is suspended, the Qt event loop runs as usual!","title":"Qt vs. co_await"},{"location":"coroutines/reading/","text":"More reading This library is inspired by Lewis Bakers' cppcoro library, which also served as a guide to implementing the coroutine machinery, alongside his great series on C++ coroutines: Coroutine Theory Understanding Operator co_await Understanding the promise type Understanding Symmetric Transfer I can also recommend numerous articles about C++ coroutines by Raymond Chen on his blog OldNewThink .","title":"Further Reading"},{"location":"coroutines/reading/#more-reading","text":"This library is inspired by Lewis Bakers' cppcoro library, which also served as a guide to implementing the coroutine machinery, alongside his great series on C++ coroutines: Coroutine Theory Understanding Operator co_await Understanding the promise type Understanding Symmetric Transfer I can also recommend numerous articles about C++ coroutines by Raymond Chen on his blog OldNewThink .","title":"More reading"},{"location":"reference/core/","text":"Core Module The Core module contains coroutine-friendly wrapper for QtCore classes. CMake usage find_package(QCoro6 COMPONENTS Core) ... target_link_libraries(my-target QCoro::Core)","title":"Core Module"},{"location":"reference/core/#core-module","text":"The Core module contains coroutine-friendly wrapper for QtCore classes.","title":"Core Module"},{"location":"reference/core/#cmake-usage","text":"find_package(QCoro6 COMPONENTS Core) ... target_link_libraries(my-target QCoro::Core)","title":"CMake usage"},{"location":"reference/core/qfuture/","text":"QFuture Module Core Include #include <QCoroFuture> CMake target_link_libraries ( myapp QCoro :: Core ) QFuture , which represents an asynchronously executed call, doesn't have any operation on its own that could be awaited asynchronously, this is usually done through a helper class called QFutureWatcher . To simplify the API, QCoro allows to directly co_await completion of the running QFuture or use a wrapper class QCoroFuture . To wrap a QFuture into a QCoroFuture , use qCoro() : template < typename T > QCoroFuture qCoro ( const QFuture < T > & future ); waitForFinished() Waits until the future is finished and then returns the result of the future (or nothing, if the future is a QFuture<void> . If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. This is a coroutine-friendly equivalent to using QFutureWatcher : QFuture < QString > future = QtConcurrent :: run ([]() { ... }); QFutureWatcher < QString > * watcher = new QFutureWatcher < QString > (); QObject :: connect ( watcher , & QFutureWatcher < QString >:: finished , this , [ watcher ]() { watcher -> deleteLater (); const QStrign result = watcher -> result (); ... }); You can also await completion of the future without using QCoroFuture at all by directly co-awaiting the QFuture object: const QString result = co_await QtConcurrent :: run ([]() { ... }); Example #include <QCoroFuture> QCoro :: Task <> runTask () { // Starts a concurrent task and co_awaits on the returned QFuture. While the task is // running, the coroutine is suspended. const QString value = co_await QtConcurrent :: run ([]() { QString result ; ... // do some long-running computation ... return result ; }); // When the future has finished, the coroutine is resumed and the result of the // QFuture is returned and stored in `value`. // ... now do something with the value }","title":"QFuture"},{"location":"reference/core/qfuture/#qfuture","text":"Module Core Include #include <QCoroFuture> CMake target_link_libraries ( myapp QCoro :: Core ) QFuture , which represents an asynchronously executed call, doesn't have any operation on its own that could be awaited asynchronously, this is usually done through a helper class called QFutureWatcher . To simplify the API, QCoro allows to directly co_await completion of the running QFuture or use a wrapper class QCoroFuture . To wrap a QFuture into a QCoroFuture , use qCoro() : template < typename T > QCoroFuture qCoro ( const QFuture < T > & future );","title":"QFuture"},{"location":"reference/core/qfuture/#waitforfinished","text":"Waits until the future is finished and then returns the result of the future (or nothing, if the future is a QFuture<void> . If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. This is a coroutine-friendly equivalent to using QFutureWatcher : QFuture < QString > future = QtConcurrent :: run ([]() { ... }); QFutureWatcher < QString > * watcher = new QFutureWatcher < QString > (); QObject :: connect ( watcher , & QFutureWatcher < QString >:: finished , this , [ watcher ]() { watcher -> deleteLater (); const QStrign result = watcher -> result (); ... }); You can also await completion of the future without using QCoroFuture at all by directly co-awaiting the QFuture object: const QString result = co_await QtConcurrent :: run ([]() { ... });","title":"waitForFinished()"},{"location":"reference/core/qfuture/#example","text":"#include <QCoroFuture> QCoro :: Task <> runTask () { // Starts a concurrent task and co_awaits on the returned QFuture. While the task is // running, the coroutine is suspended. const QString value = co_await QtConcurrent :: run ([]() { QString result ; ... // do some long-running computation ... return result ; }); // When the future has finished, the coroutine is resumed and the result of the // QFuture is returned and stored in `value`. // ... now do something with the value }","title":"Example"},{"location":"reference/core/qiodevice/","text":"QIODevice Module Core Include #include <QCoroIODevice> CMake target_link_libraries ( myapp QCoro :: Core ) Inherited By QCoroProcess , QCoroAbstractSocket , QCoroLocalSocket , QCoroNetworkReply class QCoroIODevice QIODevice has several different IO operations that can be waited on asynchronously. Since QIODevice itself doesn't provide the abaility to co_await those operations, QCoro provides a wrapper class called QCoroIODevice . To wrap a QIODevice into a QCoroIODevice , use qCoro() : QCoroIODevice qCoro ( QIODevice & ); QCoroIODevice qCoro ( QIODevice * ); Note that Qt provides several subclasses of QIODevice . QCoro provides coroutine-friendly wrappers for some of those types as well (e.g. for QLocalSocket ). This subclass can be passed to qCoro() function as well. Oftentimes the wrapper class will provide some additional features (like co_awaiting establishing connection etc.). You can check whether QCoro supports the QIODevice subclass by checking the list of supported Qt types. readAll() Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns all data available in the buffer as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the QIODevice is not opened for reading. This is the default operation when co_await ing an instance of a QIODevice directly. Thus, it is possible to just do const QByteArray content = co_await device ; instead of const QByteArray content = qCoro ( device ). readAll (); See documentation for QIODevice::readAll() for details. Awaitable auto QCoroIODevice :: readAll (); read() Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns up to maxSize bytes as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the device is not opened for reading. See documentation for QIODevice::read() for details. Awaitable auto QCoroIODevice :: read ( qint64 maxSize = 0 ); readLine() Repeatedly waits for data to arrive until it encounters a newline character, end-of-data or until it reads maxSize bytes. Returns the resulting data as QByteArray . See documentation for QIODevice::readLine() for details. Awaitable auto QCoroIODevice :: readLine ( qint64 maxSize = 0 ) Examples const QByteArray data = co_await qCoro ( device ). readAll ();","title":"QIODevice"},{"location":"reference/core/qiodevice/#qiodevice","text":"Module Core Include #include <QCoroIODevice> CMake target_link_libraries ( myapp QCoro :: Core ) Inherited By QCoroProcess , QCoroAbstractSocket , QCoroLocalSocket , QCoroNetworkReply class QCoroIODevice QIODevice has several different IO operations that can be waited on asynchronously. Since QIODevice itself doesn't provide the abaility to co_await those operations, QCoro provides a wrapper class called QCoroIODevice . To wrap a QIODevice into a QCoroIODevice , use qCoro() : QCoroIODevice qCoro ( QIODevice & ); QCoroIODevice qCoro ( QIODevice * ); Note that Qt provides several subclasses of QIODevice . QCoro provides coroutine-friendly wrappers for some of those types as well (e.g. for QLocalSocket ). This subclass can be passed to qCoro() function as well. Oftentimes the wrapper class will provide some additional features (like co_awaiting establishing connection etc.). You can check whether QCoro supports the QIODevice subclass by checking the list of supported Qt types.","title":"QIODevice"},{"location":"reference/core/qiodevice/#readall","text":"Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns all data available in the buffer as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the QIODevice is not opened for reading. This is the default operation when co_await ing an instance of a QIODevice directly. Thus, it is possible to just do const QByteArray content = co_await device ; instead of const QByteArray content = qCoro ( device ). readAll (); See documentation for QIODevice::readAll() for details. Awaitable auto QCoroIODevice :: readAll ();","title":"readAll()"},{"location":"reference/core/qiodevice/#read","text":"Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns up to maxSize bytes as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the device is not opened for reading. See documentation for QIODevice::read() for details. Awaitable auto QCoroIODevice :: read ( qint64 maxSize = 0 );","title":"read()"},{"location":"reference/core/qiodevice/#readline","text":"Repeatedly waits for data to arrive until it encounters a newline character, end-of-data or until it reads maxSize bytes. Returns the resulting data as QByteArray . See documentation for QIODevice::readLine() for details. Awaitable auto QCoroIODevice :: readLine ( qint64 maxSize = 0 )","title":"readLine()"},{"location":"reference/core/qiodevice/#examples","text":"const QByteArray data = co_await qCoro ( device ). readAll ();","title":"Examples"},{"location":"reference/core/qprocess/","text":"QProcess Module Core Include #include <QCoroProcess> CMake target_link_libraries ( myapp QCoro :: Core ) Inherits QCoroIODevice QProcess normally has two features to wait for asynchronously: the process to start and to finish. Since QProcess itself doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroProcess . To wrap a QProcess object into the QCoroProcess wrapper, use qCoro() : QCoroProcess qCoro ( QProcess & ); QCoroProcess qCoro ( QProcess * ); Same as QProcess is a subclass of QIODevice , QCoroProcess subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForStarted() Waits for the process to be started or until it times out. Returns bool indicating whether the process has started successfuly or timed out. See documentation for QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: waitForStarted ( int timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForStarted ( std :: chrono :: milliseconds timeout ); waitForFinished() Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly or timed out. See documentation for [ QProcess::waitForFinished() ][qtdoc-qprocess-waitForFinished] for details. Awaitable auto QCoroProcess :: waitForFinishedint timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForFinished ( std :: chrono :: milliseconds timeout ); start() QCoroProcess provides an additional method called start() which is equivalent to calling QProcess::start() followed by QCoroProcess::waitForStarted() . This operation is co_awaitable as well. See the documentation for QProcess::start() and QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: start ( QIODevice :: OpenMode openMode ) = QIODevice :: ReadOnly ; Awaitable auto QCoroProcess :: start ( const QString & program , const QStringList & arguments , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Examples #include <QCoroProcess> QCoro :: Task < QByteArray > listDir ( const QString & dirPath ) { QProcess basicProcess ; auto process = qCoro ( basicProcess ); qDebug () << \"Starting ls...\" ; co_await process . start ( QStringLiteral ( \"/bin/ls\" ), { dirPath }); qDebug () << \"Ls started, reading directory...\" ; co_await process . waitForFinished (); qDebug () << \"Done\" ; return basicProcess . readAll (); }","title":"QProcess"},{"location":"reference/core/qprocess/#qprocess","text":"Module Core Include #include <QCoroProcess> CMake target_link_libraries ( myapp QCoro :: Core ) Inherits QCoroIODevice QProcess normally has two features to wait for asynchronously: the process to start and to finish. Since QProcess itself doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroProcess . To wrap a QProcess object into the QCoroProcess wrapper, use qCoro() : QCoroProcess qCoro ( QProcess & ); QCoroProcess qCoro ( QProcess * ); Same as QProcess is a subclass of QIODevice , QCoroProcess subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QProcess"},{"location":"reference/core/qprocess/#waitforstarted","text":"Waits for the process to be started or until it times out. Returns bool indicating whether the process has started successfuly or timed out. See documentation for QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: waitForStarted ( int timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForStarted ( std :: chrono :: milliseconds timeout );","title":"waitForStarted()"},{"location":"reference/core/qprocess/#waitforfinished","text":"Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly or timed out. See documentation for [ QProcess::waitForFinished() ][qtdoc-qprocess-waitForFinished] for details. Awaitable auto QCoroProcess :: waitForFinishedint timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForFinished ( std :: chrono :: milliseconds timeout );","title":"waitForFinished()"},{"location":"reference/core/qprocess/#start","text":"QCoroProcess provides an additional method called start() which is equivalent to calling QProcess::start() followed by QCoroProcess::waitForStarted() . This operation is co_awaitable as well. See the documentation for QProcess::start() and QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: start ( QIODevice :: OpenMode openMode ) = QIODevice :: ReadOnly ; Awaitable auto QCoroProcess :: start ( const QString & program , const QStringList & arguments , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly );","title":"start()"},{"location":"reference/core/qprocess/#examples","text":"#include <QCoroProcess> QCoro :: Task < QByteArray > listDir ( const QString & dirPath ) { QProcess basicProcess ; auto process = qCoro ( basicProcess ); qDebug () << \"Starting ls...\" ; co_await process . start ( QStringLiteral ( \"/bin/ls\" ), { dirPath }); qDebug () << \"Ls started, reading directory...\" ; co_await process . waitForFinished (); qDebug () << \"Done\" ; return basicProcess . readAll (); }","title":"Examples"},{"location":"reference/core/qtimer/","text":"QTimer Module Core Include #include <QCoroTimer> CMake target_link_libraries ( myapp QCoro :: Core ) QTimer timer ; timer . start ( 1 s ); co_await timer ; The QCoro frameworks allows co_await ing on QTimer object. The co-awaiting coroutine is suspended, until the timer finishes, that is until QTimer::timeout() signal is emitted. The timer must be active. If the timer is not active (not started yet or already finished) the co_await expression will return immediately. To make it work, include QCoroTimer in your implementation. #include <QCoroTimer> #include <chrono> using namespace std :: chrono_literals ; QCoro :: Task <> MyClass :: pretendWork () { // Creates and starts a QTimer that will tick every second QTimer timer ; timer . setInterval ( 1 s ); timer . start (); for ( int i = 1 ; i <= 100 ; ++ i ) { // Wait for the timer to tick co_await timer ; // Update the progress bar value mProgressBar -> setValue ( i ); // And repeat... } // ... until the for loop finishes. }","title":"QTimer"},{"location":"reference/core/qtimer/#qtimer","text":"Module Core Include #include <QCoroTimer> CMake target_link_libraries ( myapp QCoro :: Core ) QTimer timer ; timer . start ( 1 s ); co_await timer ; The QCoro frameworks allows co_await ing on QTimer object. The co-awaiting coroutine is suspended, until the timer finishes, that is until QTimer::timeout() signal is emitted. The timer must be active. If the timer is not active (not started yet or already finished) the co_await expression will return immediately. To make it work, include QCoroTimer in your implementation. #include <QCoroTimer> #include <chrono> using namespace std :: chrono_literals ; QCoro :: Task <> MyClass :: pretendWork () { // Creates and starts a QTimer that will tick every second QTimer timer ; timer . setInterval ( 1 s ); timer . start (); for ( int i = 1 ; i <= 100 ; ++ i ) { // Wait for the timer to tick co_await timer ; // Update the progress bar value mProgressBar -> setValue ( i ); // And repeat... } // ... until the for loop finishes. }","title":"QTimer"},{"location":"reference/coro/","text":"Coro module The Coro module contains the fundamental coroutine functionality - the coroutine return type QCoro::Task . Another useful bit of the Coro module is the qCoro() wrapper function that wraps native Qt types into a coroutine-friendly versions supported by QCoro (check the Core, Network and DBus modules of QCoro to see which Qt types are currently supported by QCoro). If you don't want to use any of the Qt types supported by QCoro in your code, but you still want to use C++ coroutines with QCoro, you can simply just link against QCoro::Coro target in your CMakeLists.txt. This will give you all you need to start implementing custom coroutine-native types with Qt and QCoro.","title":"Coro module"},{"location":"reference/coro/#coro-module","text":"The Coro module contains the fundamental coroutine functionality - the coroutine return type QCoro::Task . Another useful bit of the Coro module is the qCoro() wrapper function that wraps native Qt types into a coroutine-friendly versions supported by QCoro (check the Core, Network and DBus modules of QCoro to see which Qt types are currently supported by QCoro). If you don't want to use any of the Qt types supported by QCoro in your code, but you still want to use C++ coroutines with QCoro, you can simply just link against QCoro::Coro target in your CMakeLists.txt. This will give you all you need to start implementing custom coroutine-native types with Qt and QCoro.","title":"Coro module"},{"location":"reference/coro/coro/","text":"qCoro() Wrapping Qt Signals Awaitable qCoro ( QObject * , QtSignalPtr ); It is possible to co_await an emission of a Qt signal. Signal arguments are returned as a result of the co_await expression: MyDialog dialog ; ... const int result = co_await qCoro ( & dialog , & QDialog :: finished ); if ( result == QDialog :: Accepted ) { ... } If the signal has more than one argument, they are returned as a tuple: QProcess process ; ... const auto [ exitCode , exitStatus ] = co_await qCoro ( & process , & QProcess :: finished ); If the signal has no arguments, then the result of the co_await expression is void . Wrapping Qt Types QCoroType qCoro ( QtClass * ); QCoroType qCoro ( QtClass & ); This function is overloaded for all Qt types supported by this library. It accepts either a pointer or a reference to a Qt type, and returns a QCoro type that wraps the Qt type and provides coroutine-friendly API for the type. Some objects have only a single asynchronous event, so it makes sense to make them directly co_await able. An example is QTimer , where only one thing can be co_await ed - the timer timeout. Thus with QCoro, it's possible to simply do this: QTimer timer ; ... co_await timer ; However, some Qt classes have multiple asynchronous operations that the user may want to co_await . For such types, simply co_await ing the class instance doesn't make sense since it's not clear what operation is being co_await ed. For those types, QCoro provides qCoro() function which returns a wrapper that provides coroutine-friendly versions of the asynchronous methods for the given type. Let's take QProcess as an example: one may want to co_await for the program to start or finish. Therefore the type must be wrapped into qCoro() like this: QProcess process ; // Wait for the process to be started co_await qCoro ( process ). start (...); // The process is running now ... ... // Wait for it to finish co_await qCoro ( process ). finished (); // The process is no longer running ... qCoro() is simply overloaded for all the Qt types currently supported by the QCoro library. The function returns a wrapper object (e.g. QCoro::detail::QCoroProcess ) which copies the QProcess API. It doesn't copy the entire API, only the bits that we want to make co_await able. When you call one of those metods (e.g. QCoroProcess::start() ), it returns an awaitable type that calls QProcess::start() , suspends the coroutine and resumes it again when the wrapped QProcess object emits the started() signal. Normally you don't need to concern yourself with anything inside the QCoro::detail namespace, it's mentioned in the previous paragraph simply to explain how the wrapper works.","title":"QCoro::coro()"},{"location":"reference/coro/coro/#qcoro","text":"","title":"qCoro()"},{"location":"reference/coro/coro/#wrapping-qt-signals","text":"Awaitable qCoro ( QObject * , QtSignalPtr ); It is possible to co_await an emission of a Qt signal. Signal arguments are returned as a result of the co_await expression: MyDialog dialog ; ... const int result = co_await qCoro ( & dialog , & QDialog :: finished ); if ( result == QDialog :: Accepted ) { ... } If the signal has more than one argument, they are returned as a tuple: QProcess process ; ... const auto [ exitCode , exitStatus ] = co_await qCoro ( & process , & QProcess :: finished ); If the signal has no arguments, then the result of the co_await expression is void .","title":"Wrapping Qt Signals"},{"location":"reference/coro/coro/#wrapping-qt-types","text":"QCoroType qCoro ( QtClass * ); QCoroType qCoro ( QtClass & ); This function is overloaded for all Qt types supported by this library. It accepts either a pointer or a reference to a Qt type, and returns a QCoro type that wraps the Qt type and provides coroutine-friendly API for the type. Some objects have only a single asynchronous event, so it makes sense to make them directly co_await able. An example is QTimer , where only one thing can be co_await ed - the timer timeout. Thus with QCoro, it's possible to simply do this: QTimer timer ; ... co_await timer ; However, some Qt classes have multiple asynchronous operations that the user may want to co_await . For such types, simply co_await ing the class instance doesn't make sense since it's not clear what operation is being co_await ed. For those types, QCoro provides qCoro() function which returns a wrapper that provides coroutine-friendly versions of the asynchronous methods for the given type. Let's take QProcess as an example: one may want to co_await for the program to start or finish. Therefore the type must be wrapped into qCoro() like this: QProcess process ; // Wait for the process to be started co_await qCoro ( process ). start (...); // The process is running now ... ... // Wait for it to finish co_await qCoro ( process ). finished (); // The process is no longer running ... qCoro() is simply overloaded for all the Qt types currently supported by the QCoro library. The function returns a wrapper object (e.g. QCoro::detail::QCoroProcess ) which copies the QProcess API. It doesn't copy the entire API, only the bits that we want to make co_await able. When you call one of those metods (e.g. QCoroProcess::start() ), it returns an awaitable type that calls QProcess::start() , suspends the coroutine and resumes it again when the wrapped QProcess object emits the started() signal. Normally you don't need to concern yourself with anything inside the QCoro::detail namespace, it's mentioned in the previous paragraph simply to explain how the wrapper works.","title":"Wrapping Qt Types"},{"location":"reference/coro/task/","text":"QCoro::Task Module Coro Include #include <Task> CMake target_link_libraries ( myapp QCoro :: Coro ) template < typename T > class QCoro :: Task Any coroutine that wants to co_await one of the types supported by the QCoro library must have return type QCoro::Task<T> , where T is the type of the \"regular\" coroutine return value. There's no need by the user to interact with or construct QCoro::Task manually, the object is constructed automatically by the compiler before the user code is executed. To return a value from a coroutine, use co_return , which will store the result in the Task object and leave the coroutine. QCoro :: Task < QString > getUserName ( UserID userId ) { ... // Obtain a QString by co_awaiting another coroutine const QString result = co_await fetchUserNameFromDb ( userId ); ... // Return the QString from the coroutine as you would from a regular function, // just use `co_return` instead of `return` keyword. co_return result ; } To obtain the result of a coroutine that returns QCoro::Task<T> , the result must be co_await ed. When the coroutine co_return s a result, the result is stored in the Task object and the co_await ing coroutine is resumed. The result is obtained from the returned Task object and returned as a result of the co_await call. QCoro :: Task < void > getUserDetails ( UserID userId ) { ... const QString name = co_await getUserName ( userId ); ... } Exception Propagation When coroutines throws an unhandled exception, the exception is stored in the Task object and is re-thrown from the co_await call in the awaiting coroutine. then() continuation Sometimes it's not possible to co_await a coroutine, for example when calling a coroutine from a reimplementation of a virtual function from a 3rd party library, where we cannot change the signature of that function to be a coroutine (e.g. a reimplementation of QAbstractItemModel::data() ). Even in this case, we want to process the result of the coroutine asynchronously, though. For such cases, Task<T> provides a then() member function that allows the caller to provide a custom callback to be invoked when the coroutine finishes. template < typename ThenCallback > requires ( std :: is_void_t < T > && std :: invocable < ThenCallback > ) || std :: invocable < ThenCallback , T > Task < R > Task < T >:: then ( ThenCallback callback ); The Task<T>::then() member function takes a callback, which must be a callable. If T is void , the ThenCallback must be a callable that has no arguments. Otherwise, ThenCallback must have exactly one argument, which is either of type T or a type implicitly convertible to T . If the return type of the ThenCallback is void , then the return type of the then() functon is Task<void> . If the return type of the ThenCallback is R or Task<R> , the return type of the then() function is Task<R> . This means that the ThenCallback can be a coroutine as well. Thanks to the return type always being of type Task<R> , it is possible to chain multiple .then() calls, or co_await the result of the entire chain. If the coroutine throws an exception, the exception is re-thrown when the result of the entire continuation is co_await ed. If the result of the continuation is not co_await ed, the exception is silently ignored. If an exception is thrown from the ThenCallback , then the exception is either propagated to the next chained then() continuation or re-thrown if directly co_await ed. If the result is not co_await ed and no futher then() continuation is chained after the one that has thrown, then the exception is silently ignored. template < typename ThenCallback , typename ErrorCallback > requires ((( std :: is_void_t < T > && std :: invocable < ThenCallback > ) || std :: invocable < ThenCallback , T > ) && std :: invocable < ErrorCallback , const std :: exception &> ) Task < R > Task < T >:: then ( ThenCallback thenCallback , ErrorCallback errorCallback ); An overload of the then() member function which takes an additional callback to be invoked when an exception is thrown from the coroutine. The ErrorCallback must be a callable that takes exactly one argument, which is const std::exception & , holding reference to the exception thrown. An exception thrown from the ErrorCallback will be re-thrown if the entire continuation is co_await ed. If another .then() continuation is chained after the current continuation and has an ErrorCallback , then the ErrorCallback will be invoked. Otherwise, the exception is silently ignored. If an exception is thrown by the non-void coroutine and is handled by the ErrorCallback , then if the resulting continuation is co_await ed, the result will be a default-constructed instance of type R (since the ThenCallback was unable to provide a proper instance of type R ). If R is not default-constructible, the program will not compile. Thus, if returning a non-default-constructible type from a coroutine that may throw an exception, we recommend to wrap the type in std::optional . Examples: QString User::name () { if ( mName . isNull ()) { mApi . fetchUserName (). then ( [ this ]( const QString & name ) { mName = name ; Q_EMIT nameChanged (); }, []( const std :: exception & e ) { mName = QStringLiteral ( \"Failed to fetch name: %1\" ). arg ( e . what ()); Q_EMIT nameChanged (); }); return QStringLiteral ( \"Loading...\" ); } else { return mName ; } } Blocking wait Sometimes it's necessary to wait for a coroutine in a blocking manner - this is especially useful in tests where possibly no event loop is running. QCoro has QCoro::waitFor() function which takes QCoro::Task<T> (that is, result of calling any QCoro-based coroutine) and blocks until the coroutine finishes. If the coroutine has a non-void return value, the value is returned from waitFor(). QCoro :: Task < int > computeAnswer () { std :: this_thread :: sleep_for ( std :: chrono :: year { 7'500'000 }); co_return 42 ; } void nonCoroutineFunction () { // The following line will block as if computeAnswer were not a coroutine. const int answer = QCoro :: waitFor ( computeAnswer ()); std :: cout << \"The answer is: \" << answer << std :: endl ; } Event loops The implementation internally uses a QEventLoop to wait for the coroutine to be completed. This means that a QCoreApplication instance must exist, although it does not need to be executed. Usual warnings about using a nested event loop apply here as well.","title":"QCoro::Task<T>"},{"location":"reference/coro/task/#qcorotask","text":"Module Coro Include #include <Task> CMake target_link_libraries ( myapp QCoro :: Coro ) template < typename T > class QCoro :: Task Any coroutine that wants to co_await one of the types supported by the QCoro library must have return type QCoro::Task<T> , where T is the type of the \"regular\" coroutine return value. There's no need by the user to interact with or construct QCoro::Task manually, the object is constructed automatically by the compiler before the user code is executed. To return a value from a coroutine, use co_return , which will store the result in the Task object and leave the coroutine. QCoro :: Task < QString > getUserName ( UserID userId ) { ... // Obtain a QString by co_awaiting another coroutine const QString result = co_await fetchUserNameFromDb ( userId ); ... // Return the QString from the coroutine as you would from a regular function, // just use `co_return` instead of `return` keyword. co_return result ; } To obtain the result of a coroutine that returns QCoro::Task<T> , the result must be co_await ed. When the coroutine co_return s a result, the result is stored in the Task object and the co_await ing coroutine is resumed. The result is obtained from the returned Task object and returned as a result of the co_await call. QCoro :: Task < void > getUserDetails ( UserID userId ) { ... const QString name = co_await getUserName ( userId ); ... } Exception Propagation When coroutines throws an unhandled exception, the exception is stored in the Task object and is re-thrown from the co_await call in the awaiting coroutine.","title":"QCoro::Task"},{"location":"reference/coro/task/#then-continuation","text":"Sometimes it's not possible to co_await a coroutine, for example when calling a coroutine from a reimplementation of a virtual function from a 3rd party library, where we cannot change the signature of that function to be a coroutine (e.g. a reimplementation of QAbstractItemModel::data() ). Even in this case, we want to process the result of the coroutine asynchronously, though. For such cases, Task<T> provides a then() member function that allows the caller to provide a custom callback to be invoked when the coroutine finishes. template < typename ThenCallback > requires ( std :: is_void_t < T > && std :: invocable < ThenCallback > ) || std :: invocable < ThenCallback , T > Task < R > Task < T >:: then ( ThenCallback callback ); The Task<T>::then() member function takes a callback, which must be a callable. If T is void , the ThenCallback must be a callable that has no arguments. Otherwise, ThenCallback must have exactly one argument, which is either of type T or a type implicitly convertible to T . If the return type of the ThenCallback is void , then the return type of the then() functon is Task<void> . If the return type of the ThenCallback is R or Task<R> , the return type of the then() function is Task<R> . This means that the ThenCallback can be a coroutine as well. Thanks to the return type always being of type Task<R> , it is possible to chain multiple .then() calls, or co_await the result of the entire chain. If the coroutine throws an exception, the exception is re-thrown when the result of the entire continuation is co_await ed. If the result of the continuation is not co_await ed, the exception is silently ignored. If an exception is thrown from the ThenCallback , then the exception is either propagated to the next chained then() continuation or re-thrown if directly co_await ed. If the result is not co_await ed and no futher then() continuation is chained after the one that has thrown, then the exception is silently ignored. template < typename ThenCallback , typename ErrorCallback > requires ((( std :: is_void_t < T > && std :: invocable < ThenCallback > ) || std :: invocable < ThenCallback , T > ) && std :: invocable < ErrorCallback , const std :: exception &> ) Task < R > Task < T >:: then ( ThenCallback thenCallback , ErrorCallback errorCallback ); An overload of the then() member function which takes an additional callback to be invoked when an exception is thrown from the coroutine. The ErrorCallback must be a callable that takes exactly one argument, which is const std::exception & , holding reference to the exception thrown. An exception thrown from the ErrorCallback will be re-thrown if the entire continuation is co_await ed. If another .then() continuation is chained after the current continuation and has an ErrorCallback , then the ErrorCallback will be invoked. Otherwise, the exception is silently ignored. If an exception is thrown by the non-void coroutine and is handled by the ErrorCallback , then if the resulting continuation is co_await ed, the result will be a default-constructed instance of type R (since the ThenCallback was unable to provide a proper instance of type R ). If R is not default-constructible, the program will not compile. Thus, if returning a non-default-constructible type from a coroutine that may throw an exception, we recommend to wrap the type in std::optional . Examples: QString User::name () { if ( mName . isNull ()) { mApi . fetchUserName (). then ( [ this ]( const QString & name ) { mName = name ; Q_EMIT nameChanged (); }, []( const std :: exception & e ) { mName = QStringLiteral ( \"Failed to fetch name: %1\" ). arg ( e . what ()); Q_EMIT nameChanged (); }); return QStringLiteral ( \"Loading...\" ); } else { return mName ; } }","title":"then() continuation"},{"location":"reference/coro/task/#blocking-wait","text":"Sometimes it's necessary to wait for a coroutine in a blocking manner - this is especially useful in tests where possibly no event loop is running. QCoro has QCoro::waitFor() function which takes QCoro::Task<T> (that is, result of calling any QCoro-based coroutine) and blocks until the coroutine finishes. If the coroutine has a non-void return value, the value is returned from waitFor(). QCoro :: Task < int > computeAnswer () { std :: this_thread :: sleep_for ( std :: chrono :: year { 7'500'000 }); co_return 42 ; } void nonCoroutineFunction () { // The following line will block as if computeAnswer were not a coroutine. const int answer = QCoro :: waitFor ( computeAnswer ()); std :: cout << \"The answer is: \" << answer << std :: endl ; } Event loops The implementation internally uses a QEventLoop to wait for the coroutine to be completed. This means that a QCoreApplication instance must exist, although it does not need to be executed. Usual warnings about using a nested event loop apply here as well.","title":"Blocking wait"},{"location":"reference/dbus/","text":"DBus Module The DBus module contains coroutine-friendly wrapper for QtDBus classes. CMake usage find_package(QCoro6 COMPONENTS DBus) ... target_link_libraries(my-target QCoro::DBus)","title":"DBus Module"},{"location":"reference/dbus/#dbus-module","text":"The DBus module contains coroutine-friendly wrapper for QtDBus classes.","title":"DBus Module"},{"location":"reference/dbus/#cmake-usage","text":"find_package(QCoro6 COMPONENTS DBus) ... target_link_libraries(my-target QCoro::DBus)","title":"CMake usage"},{"location":"reference/dbus/qdbuspendingcall/","text":"QDBusPendingCall Module DBus Include #include <QCoroDBusPendingCall> CMake target_link_libraries ( myapp QCoro :: DBus ) QDBusPendingCall on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending call or use a wrapper class QCoroDBusPendingCall . To wrap a QDBusPendingCall into a QCoroDBusPendingCall , use qCoro() : QCoroDBusPendingCall qCoro ( const QDBusPendingCall & ); To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingCall::waitForFinished() . QDBusPendingCall call = interface . asyncCall (...); const QDBusReply < ... > reply = co_await pendigCall ; QDBusPendingCall vs. QDBusPendingReply As the Qt documentation for QDBusPendingCall says, you are more likely to use QDBusPendingReply in application code than QDBusPendingCall . QCoro has explicit support for QDBusPendingCall to allow using functions that return QDBusPendingCall directly in co_await expressions without the programmer having to first convert it to QDBusPendingReply . QDBusPendingReply can be constructed from a QDBusMessage , which is a result of awaiting QDBusPendingCall , therefore it's possible to perform both the conversion and awaiting in a single line of code: QDBusPendingReply < ... > reply = co_await iface . asyncCall (...); Note that QDBusAbstractInterface::asyncCall returns a QDBusPendingCall . waitForFinished() Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the reply to the call. If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. It is also possible to just directly use a QDBusPendingCall in a co_await expression to await its completion: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await pendingCall ; The above is equivalent to: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingCall ). waitForFinished (); This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusReply < ... > reply = * watcher ; ... }); Example #include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"QDBusPendingCall"},{"location":"reference/dbus/qdbuspendingcall/#qdbuspendingcall","text":"Module DBus Include #include <QCoroDBusPendingCall> CMake target_link_libraries ( myapp QCoro :: DBus ) QDBusPendingCall on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending call or use a wrapper class QCoroDBusPendingCall . To wrap a QDBusPendingCall into a QCoroDBusPendingCall , use qCoro() : QCoroDBusPendingCall qCoro ( const QDBusPendingCall & ); To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingCall::waitForFinished() . QDBusPendingCall call = interface . asyncCall (...); const QDBusReply < ... > reply = co_await pendigCall ; QDBusPendingCall vs. QDBusPendingReply As the Qt documentation for QDBusPendingCall says, you are more likely to use QDBusPendingReply in application code than QDBusPendingCall . QCoro has explicit support for QDBusPendingCall to allow using functions that return QDBusPendingCall directly in co_await expressions without the programmer having to first convert it to QDBusPendingReply . QDBusPendingReply can be constructed from a QDBusMessage , which is a result of awaiting QDBusPendingCall , therefore it's possible to perform both the conversion and awaiting in a single line of code: QDBusPendingReply < ... > reply = co_await iface . asyncCall (...); Note that QDBusAbstractInterface::asyncCall returns a QDBusPendingCall .","title":"QDBusPendingCall"},{"location":"reference/dbus/qdbuspendingcall/#waitforfinished","text":"Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the reply to the call. If the call is already finished or has an error, the coroutine will not suspend and the co_await expression will return immediatelly. It is also possible to just directly use a QDBusPendingCall in a co_await expression to await its completion: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await pendingCall ; The above is equivalent to: QDBusPendingCall pendingCall = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingCall ). waitForFinished (); This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusReply < ... > reply = * watcher ; ... });","title":"waitForFinished()"},{"location":"reference/dbus/qdbuspendingcall/#example","text":"#include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"Example"},{"location":"reference/dbus/qdbuspendingreply/","text":"QDBusPendingReply Module DBus Include #include <QCoroDBusPendingReply> CMake target_link_libraries ( myapp QCoro :: DBus ) QDBusPendingReply on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending reply or use a wrapper class QCoroDBusPendingReply . To wrap a QDBusPendingReply into a QCoroDBusPendingReply , use qCoro() : template < typename ... Args > QCoroDBusPendingCall qCoro ( const QDBusPendingReply < Args ... > & ); QDBusPendingReply in Qt5 vs Qt6 QDBusPendingReply in Qt6 is a variadic template, meaning that it can take any amount of template arguments. In Qt5, however, QDBusPendingReply is a template class that accepts only up to 8 paremeters. In QCoro the QCoroDBusPendingReply wrapper is implemented as a variadic template for compatibility with Qt6, but when building against Qt5, the number of template parameters is artificially limited to 8 to mirror the limitation of Qt5 QDBusPendingReply limitation. To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingReply::waitForFinished() . QDBusPendingReply < ... > reply = interface . asyncCall (...); co_await reply ; // Now the reply is finished and the result can be retrieved. waitForFinished() Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the received reply. If the reply is already finished or an error has occurred the coroutine will not suspend and will return a result immediatelly. This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusReply < ... > reply = * watcher ; ... }); It is also possible to just directly use a QDBusPendingReply in a co_await expression to await its completion: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await pendingReply ; The above is equivalent to: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingReply ). waitForFinished (); Example #include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"QDBusPendingReply"},{"location":"reference/dbus/qdbuspendingreply/#qdbuspendingreply","text":"Module DBus Include #include <QCoroDBusPendingReply> CMake target_link_libraries ( myapp QCoro :: DBus ) QDBusPendingReply on its own doesn't have any operation that could be awaited asynchronously, this is usually done through a helper class called QDBusPendingCallWatcher . To simplify the API, QCoro allows to directly co_await completion of the pending reply or use a wrapper class QCoroDBusPendingReply . To wrap a QDBusPendingReply into a QCoroDBusPendingReply , use qCoro() : template < typename ... Args > QCoroDBusPendingCall qCoro ( const QDBusPendingReply < Args ... > & ); QDBusPendingReply in Qt5 vs Qt6 QDBusPendingReply in Qt6 is a variadic template, meaning that it can take any amount of template arguments. In Qt5, however, QDBusPendingReply is a template class that accepts only up to 8 paremeters. In QCoro the QCoroDBusPendingReply wrapper is implemented as a variadic template for compatibility with Qt6, but when building against Qt5, the number of template parameters is artificially limited to 8 to mirror the limitation of Qt5 QDBusPendingReply limitation. To await completion of the pending call without the qCoro wrapper, just use the pending call in a co_await expression. The behavior is identical to awaiting on result of QCoroDBusPendingReply::waitForFinished() . QDBusPendingReply < ... > reply = interface . asyncCall (...); co_await reply ; // Now the reply is finished and the result can be retrieved.","title":"QDBusPendingReply"},{"location":"reference/dbus/qdbuspendingreply/#waitforfinished","text":"Waits until the DBus call is finished. This is equivalent to using QDBusPendingCallWatcher and waiting for it to emit the finished() signal. Returns a QDBusMessage representing the received reply. If the reply is already finished or an error has occurred the coroutine will not suspend and will return a result immediatelly. This is a coroutine-friendly equivalent to using QDBusPendingCallWatcher : QDBusPendingCall call = interface . asyncCall (...); QDBusPendingCallWatcher * watcher = new QDBusPendingCallWatcher ( call ); QObject :: connect ( watcher , & QDBusPendingCallWatcher :: finished , this , []( QDBusPendingCallWatcher * watcher ) { watcher -> deleteLater (); const QDBusReply < ... > reply = * watcher ; ... }); It is also possible to just directly use a QDBusPendingReply in a co_await expression to await its completion: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await pendingReply ; The above is equivalent to: QDBusPendingReply < ... > pendingReply = interface . asyncCall (...); const auto reply = co_await qCoro ( pendingReply ). waitForFinished ();","title":"waitForFinished()"},{"location":"reference/dbus/qdbuspendingreply/#example","text":"#include <QCoroDBus> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"Example"},{"location":"reference/network/","text":"Network Module The Network module contains coroutine-friendly wrapper for QtNetwork classes. CMake usage find_package(QCoro6 COMPONENTS Network) ... target_link_libraries(my-target QCoro::Network)","title":"Network Module"},{"location":"reference/network/#network-module","text":"The Network module contains coroutine-friendly wrapper for QtNetwork classes.","title":"Network Module"},{"location":"reference/network/#cmake-usage","text":"find_package(QCoro6 COMPONENTS Network) ... target_link_libraries(my-target QCoro::Network)","title":"CMake usage"},{"location":"reference/network/qabstractsocket/","text":"QAbstractSocket Module Network Include #include <QCoroAbstractSocket> CMake target_link_libraries ( myapp QCoro :: Network ) Inherits QCoroIODevice QAbstractSocket is a base class for QTcpSocket and QUdpSocket and has some potentially asynchronous operations. In addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QAbstractSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroAbstractSocket . To wrap a QAbstractSocket object into the QCoroAbstractSocket wrapper, use qCoro() : QCoroAbstractSocket qCoro ( QAbstractSocket & ); QCoroAbstractSocket qCoro ( QAbstractSocket * ); Same as QAbstractSocket is a subclass of QIODevice , QCoroAbstractSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForConnected() Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForConnected ( std :: chrono :: milliseconds timeout ); waitForDisconnected() Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QAbstractSocket::waitForDisconnected() for details. Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout ); connectToHost() QCoroAbstractSocket provides an additional method called connectToHost() which is equivalent to calling QAbstractSocket::connectToHost() followed by QAbstractSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for [ QAbstractSocket::connectToHost() ][qtdoc-qabstractsocket-connectToHost] and QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: connectToHost ( const QHostAddress & address , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroAbstractSocket :: connectToHost ( const QString & hostName , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , QAbstractSocket :: NetworkLayerProtocol protocol = QAbstractSocket :: AnyIPProtocol ); Examples #include <QCoroTcpSocket> QCoro :: Task < QByteArray > requestDataFromServer ( const QString & hostName ) { QTcpSocket socket ; if ( ! co_await qCoro ( socket ). connectToHost ( hostName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; } `","title":"QAbstractSocket"},{"location":"reference/network/qabstractsocket/#qabstractsocket","text":"Module Network Include #include <QCoroAbstractSocket> CMake target_link_libraries ( myapp QCoro :: Network ) Inherits QCoroIODevice QAbstractSocket is a base class for QTcpSocket and QUdpSocket and has some potentially asynchronous operations. In addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QAbstractSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroAbstractSocket . To wrap a QAbstractSocket object into the QCoroAbstractSocket wrapper, use qCoro() : QCoroAbstractSocket qCoro ( QAbstractSocket & ); QCoroAbstractSocket qCoro ( QAbstractSocket * ); Same as QAbstractSocket is a subclass of QIODevice , QCoroAbstractSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QAbstractSocket"},{"location":"reference/network/qabstractsocket/#waitforconnected","text":"Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForConnected ( std :: chrono :: milliseconds timeout );","title":"waitForConnected()"},{"location":"reference/network/qabstractsocket/#waitfordisconnected","text":"Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QAbstractSocket::waitForDisconnected() for details. Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout );","title":"waitForDisconnected()"},{"location":"reference/network/qabstractsocket/#connecttohost","text":"QCoroAbstractSocket provides an additional method called connectToHost() which is equivalent to calling QAbstractSocket::connectToHost() followed by QAbstractSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for [ QAbstractSocket::connectToHost() ][qtdoc-qabstractsocket-connectToHost] and QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: connectToHost ( const QHostAddress & address , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroAbstractSocket :: connectToHost ( const QString & hostName , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , QAbstractSocket :: NetworkLayerProtocol protocol = QAbstractSocket :: AnyIPProtocol );","title":"connectToHost()"},{"location":"reference/network/qabstractsocket/#examples","text":"#include <QCoroTcpSocket> QCoro :: Task < QByteArray > requestDataFromServer ( const QString & hostName ) { QTcpSocket socket ; if ( ! co_await qCoro ( socket ). connectToHost ( hostName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; } `","title":"Examples"},{"location":"reference/network/qlocalsocket/","text":"QLocalSocket Module Network Include #include <QCoroLocalSocket> CMake target_link_libraries ( myapp QCoro :: Network ) Inherits QCoroIODevice QLocalSocket has several potentially asynchronous operations in addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QLocalSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroLocalSocket . To wrap a QLocalSocket object into the QCoroLocalSocket wrapper, use qCoro() : QCoroLocalSocket qCoro ( QLocalSocket & ); QCoroLocalSocket qCoro ( QLocalSocket * ); Same as QLocalSocket is a subclass of QIODevice , QCoroLocalSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForConnected() Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForConnected ( std :: chrono :: milliseconds timeout ); waitForDisconnected() Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QLocalSocket::waitForDisconnected() for details. Awaitable auto QCoroLocalSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout ); connectToServer() QCoroLocalSocket provides an additional method called connectToServer() which is equivalent to calling QLocalSocket::connectToServer() followed by QLocalSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for QLocalSocket::connectToServer() and QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: connectToServer ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroLocalSocket :: connectToServer ( const QString & name , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Examples QCoro :: Task < QByteArray > requestDataFromServer ( const QString & serverName ) { QLocalSocket socket ; if ( ! co_await qCoro ( socket ). connectToServer ( serverName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"QLocalSocket"},{"location":"reference/network/qlocalsocket/#qlocalsocket","text":"Module Network Include #include <QCoroLocalSocket> CMake target_link_libraries ( myapp QCoro :: Network ) Inherits QCoroIODevice QLocalSocket has several potentially asynchronous operations in addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QLocalSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroLocalSocket . To wrap a QLocalSocket object into the QCoroLocalSocket wrapper, use qCoro() : QCoroLocalSocket qCoro ( QLocalSocket & ); QCoroLocalSocket qCoro ( QLocalSocket * ); Same as QLocalSocket is a subclass of QIODevice , QCoroLocalSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QLocalSocket"},{"location":"reference/network/qlocalsocket/#waitforconnected","text":"Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForConnected ( std :: chrono :: milliseconds timeout );","title":"waitForConnected()"},{"location":"reference/network/qlocalsocket/#waitfordisconnected","text":"Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QLocalSocket::waitForDisconnected() for details. Awaitable auto QCoroLocalSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout );","title":"waitForDisconnected()"},{"location":"reference/network/qlocalsocket/#connecttoserver","text":"QCoroLocalSocket provides an additional method called connectToServer() which is equivalent to calling QLocalSocket::connectToServer() followed by QLocalSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for QLocalSocket::connectToServer() and QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: connectToServer ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroLocalSocket :: connectToServer ( const QString & name , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly );","title":"connectToServer()"},{"location":"reference/network/qlocalsocket/#examples","text":"QCoro :: Task < QByteArray > requestDataFromServer ( const QString & serverName ) { QLocalSocket socket ; if ( ! co_await qCoro ( socket ). connectToServer ( serverName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"Examples"},{"location":"reference/network/qnetworkreply/","text":"QNetworkReply Module Network Include #include <QCoroNetworkReply> CMake target_link_libraries ( myapp QCoro :: Network ) Inherits QCoroIODevice QNetworkReply has two asynchronous aspects: one is waiting for the reply to finish, and one for reading the response data as they arrive. QCoro supports both. QNetworkReply is a subclass of QIODevice , so you can leverage all the features of QCoroIODevice to asynchronously read data from the underlying QIODevice using coroutines. To wait for the reply to finish, one can simply co_await the reply object: QNetworkAccessManager nam ; auto * reply = co_await nam . get ( request ); The QCoro frameworks allows co_await ing on QNetworkReply objects. The co-awaiting coroutine is suspended, until QNetworkReply::finished() signal is emitted. To make it work, include QCoroNetworkReply in your implementation. #include <QCoroNetworkReply> QCoro :: Task <> MyClass :: fetchData () { // Creates QNetworkAccessManager on stack QNetworkAccessManager nam ; // Calls QNetworkAccessManager::get() and co_awaits on the returned QNetworkReply* // until it finishes. The current coroutine is suspended until that. auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); // When the reply finishes, the coroutine is resumed and we can access the reply content. const auto data = reply -> readAll (); // Raise your hand if you never forgot to delete a QNetworkReply... delete reply ; doSomethingWithData ( data ); // Extra bonus: the QNetworkAccessManager is destroyed automatically, since it's on stack. }","title":"QNetworkReply"},{"location":"reference/network/qnetworkreply/#qnetworkreply","text":"Module Network Include #include <QCoroNetworkReply> CMake target_link_libraries ( myapp QCoro :: Network ) Inherits QCoroIODevice QNetworkReply has two asynchronous aspects: one is waiting for the reply to finish, and one for reading the response data as they arrive. QCoro supports both. QNetworkReply is a subclass of QIODevice , so you can leverage all the features of QCoroIODevice to asynchronously read data from the underlying QIODevice using coroutines. To wait for the reply to finish, one can simply co_await the reply object: QNetworkAccessManager nam ; auto * reply = co_await nam . get ( request ); The QCoro frameworks allows co_await ing on QNetworkReply objects. The co-awaiting coroutine is suspended, until QNetworkReply::finished() signal is emitted. To make it work, include QCoroNetworkReply in your implementation. #include <QCoroNetworkReply> QCoro :: Task <> MyClass :: fetchData () { // Creates QNetworkAccessManager on stack QNetworkAccessManager nam ; // Calls QNetworkAccessManager::get() and co_awaits on the returned QNetworkReply* // until it finishes. The current coroutine is suspended until that. auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); // When the reply finishes, the coroutine is resumed and we can access the reply content. const auto data = reply -> readAll (); // Raise your hand if you never forgot to delete a QNetworkReply... delete reply ; doSomethingWithData ( data ); // Extra bonus: the QNetworkAccessManager is destroyed automatically, since it's on stack. }","title":"QNetworkReply"},{"location":"reference/network/qtcpserver/","text":"QTcpServer Module Network Include #include <QCoroTcpServer> CMake target_link_libraries ( myapp QCoro :: Network ) QTcpServer really only has one asynchronous operation worth co_await ing, and that's waitForNewConnection() . Since QTcpServer doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroTcpServer . To wrap a QTcpServer object into the QCoroTcpServer wrapper, use qCoro() : QCoroTcpServer qCoro ( QTcpServer & ); QCoroTcpServer qCoro ( QTcpServer * ); waitForNewConnection() Waits until a new incoming connection is available or until it times out. Returns pointer to QTcpSocket or nullptr if the operation timed out or another error has occured. See documentation for QTcpServer::waitForNewConnection() for details. Awaitable auto QCoroTcpServer :: waitForNewConnection ( int timeout_msecs = 30'000 ); Awaitable auto QCoroTcpServer :: waitForNewConnection ( std :: chrono :: milliseconds timeout ); Examples #include <QCoroTcpServer> QCoro :: Task <> runServer ( uint16_t port ) { QTcpServer server ; server . listen ( QHostAddress :: LocalHost , port ); while ( server . isListening ()) { auto * socket = co_await qCoro ( server ). waitForNewConnection ( 10 s ); if ( socket != nullptr ) { newClientConnection ( socket ); } } }","title":"QTcpServer"},{"location":"reference/network/qtcpserver/#qtcpserver","text":"Module Network Include #include <QCoroTcpServer> CMake target_link_libraries ( myapp QCoro :: Network ) QTcpServer really only has one asynchronous operation worth co_await ing, and that's waitForNewConnection() . Since QTcpServer doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroTcpServer . To wrap a QTcpServer object into the QCoroTcpServer wrapper, use qCoro() : QCoroTcpServer qCoro ( QTcpServer & ); QCoroTcpServer qCoro ( QTcpServer * );","title":"QTcpServer"},{"location":"reference/network/qtcpserver/#waitfornewconnection","text":"Waits until a new incoming connection is available or until it times out. Returns pointer to QTcpSocket or nullptr if the operation timed out or another error has occured. See documentation for QTcpServer::waitForNewConnection() for details. Awaitable auto QCoroTcpServer :: waitForNewConnection ( int timeout_msecs = 30'000 ); Awaitable auto QCoroTcpServer :: waitForNewConnection ( std :: chrono :: milliseconds timeout );","title":"waitForNewConnection()"},{"location":"reference/network/qtcpserver/#examples","text":"#include <QCoroTcpServer> QCoro :: Task <> runServer ( uint16_t port ) { QTcpServer server ; server . listen ( QHostAddress :: LocalHost , port ); while ( server . isListening ()) { auto * socket = co_await qCoro ( server ). waitForNewConnection ( 10 s ); if ( socket != nullptr ) { newClientConnection ( socket ); } } }","title":"Examples"}]}